["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$fsm.core","~:imports",null,"~:requires",["^ ","~$impl","~$fsm.impl","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$add-effect",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","~:line",7,"~:column",7,"~:end-line",7,"~:end-column",17,"~:arglists",["~#list",["~$quote",["^G",[["~$sm","~$key","~$fn-3"],["^I","^J","~$from","~$to","^K"]]]]],"~:doc","Register a function to be called in response to a state change.\n   \n   The given key should be unique for the given state machine.\n\n   The effect fn must be an fn of 3 args: the state machine, the old state, and the new state.\n   \n   When add-effect is invoked with three arguments, the effect fn will be called\n   when any state change occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::fun (fn [synth old-state new-state]\n                                      (do-something-fun synth old-state new-state)))\n   ```\n   \n   When add-effect is called with five arguments, the effect fn will be called when\n   an explicit state transition occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::resumed :paused :speaking on-resume)\n   ```\n\n   The previous state value can also be a set of previous states:\n\n   ```clojure\n   (add-effect my-microphone ::init #{:dormant :stopped} :ready on-ready)\n   ```\n   \n   The add-effect function is useful for monitoring state changes or dispatching\n   other effects in response to state changes.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",5,"~:max-fixed-arity",5,"~:method-params",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]],"^F",["^G",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]]],"~:arglists-meta",["^G",[null,null]]]],"^5","~$fsm.core/add-effect","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^E",17,"^O",["^ ","^P",false,"^Q",5,"^R",5,"^S",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]],"^F",["^G",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]]],"^T",["^G",[null,null]]],"^S",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]],"~:protocol-impl",null,"^Q",5,"^T",["^G",[null,null]],"^C",1,"^P",false,"~:methods",[["^ ","^Q",3,"^P",false],["^ ","^Q",5,"^P",false,"~:tag","~$any"]],"^B",7,"^D",7,"^R",5,"~:fn-var",true,"^F",["^G",[["^I","^J","^K"],["^I","^J","^L","^M","^K"]]],"^N","Register a function to be called in response to a state change.\n   \n   The given key should be unique for the given state machine.\n\n   The effect fn must be an fn of 3 args: the state machine, the old state, and the new state.\n   \n   When add-effect is invoked with three arguments, the effect fn will be called\n   when any state change occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::fun (fn [synth old-state new-state]\n                                      (do-something-fun synth old-state new-state)))\n   ```\n   \n   When add-effect is called with five arguments, the effect fn will be called when\n   an explicit state transition occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::resumed :paused :speaking on-resume)\n   ```\n\n   The previous state value can also be a set of previous states:\n\n   ```clojure\n   (add-effect my-microphone ::init #{:dormant :stopped} :ready on-ready)\n   ```\n   \n   The add-effect function is useful for monitoring state changes or dispatching\n   other effects in response to state changes."],"~$transition",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^B",43,"^C",7,"^D",43,"^E",17,"^F",["^G",["^H",["^G",[["^I","~$event","~$payload"],["^I","^10"]]]]],"^N","Transition a state machine using the given event and an optional payload.\n   \n   The payload can be a hash map (or nil) or a function that returns a hash map (or nil). If a function, the\n   payload must be a function of 1 arg: the state machine itself.\n   \n   The payload hash map will replace the state machine's internal state entirely. A function\n   payload may be useful for merging state instead of replacing it entirely.\n   \n   ```clojure\n   ;;; Set state to the given data\n   (core/transition this :init {:recognition          recognition\n                                :speech-ch            speech-ch\n                                :listener/result      on-result})\n   \n   ;;; Maintain current state\n   (core/transition this :pause some-fn-that-just-returns-the-current-state)\n\n   ;;; Set the current state to nil by omitting the payload altogether\n   (core/transition this :stop)\n   ```","^O",["^ ","^P",false,"^Q",3,"^R",3,"^S",[["^I","^10","^11"],["^I","^10"]],"^F",["^G",[["^I","^10","^11"],["^I","^10"]]],"^T",["^G",[null,null]]]],"^5","~$fsm.core/transition","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^E",17,"^O",["^ ","^P",false,"^Q",3,"^R",3,"^S",[["^I","^10","^11"],["^I","^10"]],"^F",["^G",[["^I","^10","^11"],["^I","^10"]]],"^T",["^G",[null,null]]],"^S",[["^I","^10","^11"],["^I","^10"]],"^V",null,"^Q",3,"^T",["^G",[null,null]],"^C",1,"^P",false,"^W",[["^ ","^Q",3,"^P",false],["^ ","^Q",2,"^P",false,"^X","^Y"]],"^B",43,"^D",43,"^R",3,"^Z",true,"^F",["^G",[["^I","^10","^11"],["^I","^10"]]],"^N","Transition a state machine using the given event and an optional payload.\n   \n   The payload can be a hash map (or nil) or a function that returns a hash map (or nil). If a function, the\n   payload must be a function of 1 arg: the state machine itself.\n   \n   The payload hash map will replace the state machine's internal state entirely. A function\n   payload may be useful for merging state instead of replacing it entirely.\n   \n   ```clojure\n   ;;; Set state to the given data\n   (core/transition this :init {:recognition          recognition\n                                :speech-ch            speech-ch\n                                :listener/result      on-result})\n   \n   ;;; Maintain current state\n   (core/transition this :pause some-fn-that-just-returns-the-current-state)\n\n   ;;; Set the current state to nil by omitting the payload altogether\n   (core/transition this :stop)\n   ```"],"~$current-state",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^B",70,"^C",7,"^D",70,"^E",20,"^F",["^G",["^H",["^G",[["^I"]]]]],"^N","Returns the current state of the given state machine as a hash map.\n   \n   ```clojure\n   (-> state-machine current-state :count)\n   ```"],"^5","~$fsm.core/current-state","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^E",20,"^S",["^G",[["^I"]]],"^V",null,"^T",["^G",[null,null]],"^C",1,"^P",false,"^B",70,"~:ret-tag","^Y","^D",70,"^R",1,"^Z",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^N","Returns the current state of the given state machine as a hash map.\n   \n   ```clojure\n   (-> state-machine current-state :count)\n   ```"],"~$create-state-machine",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^B",79,"^C",7,"^D",79,"^E",27,"^F",["^G",["^H",["^G",[["~$states","~$initial-state"],["^17","^18","~$atom-fn"]]]]],"^N","Create a state machine backed by atoms.\n   \n   This function can be called with three arguments to specify the function\n   used for creating the atom. This is useful for atom like types such as reagent's\n   ratoms:\n   \n   ```clojure\n   (create-state-machine states default reagent.core/atom)\n   ```\n   \n   The states map should be a hash map indicating supported states and their\n   allowed transitions. A transition key is a named event and the transition\n   value is the expected state after said event occurs:\n   \n   ```clojure\n   {:speaking {:pause :paused}\n    :paused   {:resume :speaking}}\n   ```\n   \n   The above state map indicates that only when the state machine is in a speaking state,\n   can a pause event be used via core.transition to move the machine to a paused state. Similarly,\n   only a paused machine can be resumed to a speaking state via a resume event.\n   \n   The initial-state must be a map that will be used as the initial value of the underlying\n   atom map's :data value.\n   \n   If an atom-fn is given, it will be called with the initial state provided\n   to this function. This may be useful for something like using reagent's \"ratoms\" instead of\n   Clojure's own atoms.","^O",["^ ","^P",false,"^Q",3,"^R",3,"^S",[["^17","^18"],["^17","^18","^19"]],"^F",["^G",[["^17","^18"],["^17","^18","^19"]]],"^T",["^G",[null,null]]]],"^5","~$fsm.core/create-state-machine","^A","/Users/brian/.cljs/.aot_cache/1.11.4/DED080F/fsm/core.cljc","^E",27,"^O",["^ ","^P",false,"^Q",3,"^R",3,"^S",[["^17","^18"],["^17","^18","^19"]],"^F",["^G",[["^17","^18"],["^17","^18","^19"]]],"^T",["^G",[null,null]]],"^S",[["^17","^18"],["^17","^18","^19"]],"^V",null,"^Q",3,"^T",["^G",[null,null]],"^C",1,"^P",false,"^W",[["^ ","^Q",2,"^P",false,"^X","^Y"],["^ ","^Q",3,"^P",false,"^X","~$fsm.impl/AtomStateMachine"]],"^B",79,"^D",79,"^R",3,"^Z",true,"^F",["^G",[["^17","^18"],["^17","^18","^19"]]],"^N","Create a state machine backed by atoms.\n   \n   This function can be called with three arguments to specify the function\n   used for creating the atom. This is useful for atom like types such as reagent's\n   ratoms:\n   \n   ```clojure\n   (create-state-machine states default reagent.core/atom)\n   ```\n   \n   The states map should be a hash map indicating supported states and their\n   allowed transitions. A transition key is a named event and the transition\n   value is the expected state after said event occurs:\n   \n   ```clojure\n   {:speaking {:pause :paused}\n    :paused   {:resume :speaking}}\n   ```\n   \n   The above state map indicates that only when the state machine is in a speaking state,\n   can a pause event be used via core.transition to move the machine to a paused state. Similarly,\n   only a paused machine can be resumed to a speaking state via a resume event.\n   \n   The initial-state must be a map that will be used as the initial value of the underlying\n   atom map's :data value.\n   \n   If an atom-fn is given, it will be called with the initial state provided\n   to this function. This may be useful for something like using reagent's \"ratoms\" instead of\n   Clojure's own atoms."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:fsm/state","~:fsm/last-event"]],"~:order",["^1@","^1A"]],"^N","This is yet another fsm library. I just want simple transitions and the ability\n   to add side effects. If you want these things too, then I want to share this library\n   with you."]